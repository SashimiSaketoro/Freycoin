// Copyright (c) 2025 The Freycoin developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

/**
 * Metal Fermat Primality Test Implementation
 *
 * Native Apple Silicon GPU backend with zero-copy unified memory.
 * Uses MTLResourceStorageModeShared to avoid host<->device copies.
 *
 * In memory of Jonnie Frey (1989-2017), creator of Gapcoin.
 */

#import <Metal/Metal.h>
#import <Foundation/Foundation.h>

#include "metal_fermat.h"

#include <stdio.h>
#include <string.h>

/* Safe error description extraction — avoids passing NULL to fprintf %s
 * when the NSError is nil (which is UB and typically crashes). */
static const char* metal_errstr(NSError *err) {
    return err ? [[err localizedDescription] UTF8String] : "(unknown error)";
}

/* Global Metal state */
static id<MTLDevice> g_device = nil;
static id<MTLCommandQueue> g_queue = nil;
static id<MTLComputePipelineState> g_pipeline_320 = nil;
static id<MTLComputePipelineState> g_pipeline_352 = nil;
static int g_initialized = 0;
static char g_device_name[256] = {0};

/* Persistent shared-memory buffers for zero-copy (reused across batches) */
static id<MTLBuffer> g_primes_buf = nil;
static id<MTLBuffer> g_results_buf = nil;
static id<MTLBuffer> g_count_buf = nil;
static uint32_t g_max_candidates = 0;
static int g_max_bits = 352;  /* Allocate for largest limb count */

/* Thread execution width for optimal dispatch */
static NSUInteger g_thread_width = 64;

/*============================================================================
 * Embedded metallib (generated at build time by CMake)
 * Falls back to runtime compilation from source if not available.
 *============================================================================*/

/* Forward declaration — the metallib byte array is generated by CMake.
 * If it's not available (e.g. during development), we fall back to
 * compiling from the .metal source file at runtime. */
extern const unsigned char fermat_metallib_data[] __attribute__((weak));
extern const unsigned long fermat_metallib_size __attribute__((weak));

static id<MTLLibrary> load_metal_library(id<MTLDevice> device) {
    NSError *error = nil;

    /* Try embedded metallib first */
    if (&fermat_metallib_data != NULL && &fermat_metallib_size != NULL && fermat_metallib_size > 0) {
        /* SECURITY: fermat_metallib_data is a static/const array embedded by
         * the linker.  DISPATCH_DATA_DESTRUCTOR_DEFAULT would call free() on
         * it when the dispatch_data_t is released, which is UB (crash).
         * Use a no-op destructor block instead. */
        dispatch_data_t data = dispatch_data_create(fermat_metallib_data,
                                                     fermat_metallib_size,
                                                     nil,
                                                     ^{});
        id<MTLLibrary> lib = [device newLibraryWithData:data error:&error];
        if (lib) return lib;
        fprintf(stderr, "Metal: embedded metallib failed: %s\n", metal_errstr(error));
    }

    /* Try loading .metallib file from same directory as executable */
    NSBundle *bundle = [NSBundle mainBundle];
    NSString *libPath = [bundle pathForResource:@"fermat" ofType:@"metallib"];
    if (libPath) {
        NSURL *url = [NSURL fileURLWithPath:libPath];
        id<MTLLibrary> lib = [device newLibraryWithURL:url error:&error];
        if (lib) return lib;
    }

    /* Try compiling from .metal source file at runtime */
    NSString *sourcePath = @"fermat_metal.metal";
    NSString *source = [NSString stringWithContentsOfFile:sourcePath
                                                encoding:NSUTF8StringEncoding
                                                   error:&error];
    if (source) {
        MTLCompileOptions *opts = [[MTLCompileOptions alloc] init];
        opts.fastMathEnabled = NO;  /* Need exact integer arithmetic */
        id<MTLLibrary> lib = [device newLibraryWithSource:source
                                                  options:opts
                                                    error:&error];
        if (lib) return lib;
        fprintf(stderr, "Metal: source compilation failed: %s\n", metal_errstr(error));
    }

    /* Fallback: default library (if metal files are compiled into the app) */
    id<MTLLibrary> lib = [device newDefaultLibrary];
    if (lib) return lib;

    fprintf(stderr, "Metal: no library available\n");
    return nil;
}

/*============================================================================
 * Buffer Management
 *============================================================================*/

static int ensure_buffers(uint32_t count, int bits) {
    int limbs = (bits <= 320) ? 10 : 11;
    size_t primes_size = (size_t)count * limbs * sizeof(uint32_t);
    size_t results_size = (size_t)count * sizeof(uint8_t);

    /* Check if existing buffers are large enough */
    if (g_primes_buf && g_results_buf &&
        [g_primes_buf length] >= primes_size &&
        [g_results_buf length] >= results_size) {
        return 0;
    }

    /* Allocate or reallocate with some headroom */
    uint32_t alloc_count = count + (count / 4);  /* 25% headroom */
    if (alloc_count < 1024) alloc_count = 1024;
    int max_limbs = 11;  /* Always allocate for 352-bit to avoid resizing */
    size_t alloc_primes = (size_t)alloc_count * max_limbs * sizeof(uint32_t);
    size_t alloc_results = (size_t)alloc_count * sizeof(uint8_t);

    /* Round up to page size for optimal unified memory performance */
    size_t page_size = 16384;  /* Apple Silicon uses 16K pages */
    alloc_primes = ((alloc_primes + page_size - 1) / page_size) * page_size;
    alloc_results = ((alloc_results + page_size - 1) / page_size) * page_size;

    g_primes_buf = [g_device newBufferWithLength:alloc_primes
                                         options:MTLResourceStorageModeShared];
    g_results_buf = [g_device newBufferWithLength:alloc_results
                                          options:MTLResourceStorageModeShared];

    if (!g_primes_buf || !g_results_buf) {
        fprintf(stderr, "Metal: buffer allocation failed\n");
        return -1;
    }

    /* Allocate count buffer (just 4 bytes, reused) */
    if (!g_count_buf) {
        g_count_buf = [g_device newBufferWithLength:sizeof(uint32_t)
                                            options:MTLResourceStorageModeShared];
        if (!g_count_buf) return -1;
    }

    g_max_candidates = alloc_count;
    g_max_bits = 352;
    return 0;
}

/*============================================================================
 * Public API
 *============================================================================*/

int metal_fermat_init(int device_id) {
    if (g_initialized) return 0;

    @autoreleasepool {
        /* Get Metal device */
        NSArray<id<MTLDevice>> *devices = MTLCopyAllDevices();
        if (!devices || [devices count] == 0) {
            /* Try system default */
            g_device = MTLCreateSystemDefaultDevice();
            if (!g_device) return -2;
        } else {
            NSUInteger idx = (device_id >= 0 && (NSUInteger)device_id < [devices count])
                             ? (NSUInteger)device_id : 0;
            g_device = devices[idx];
        }

        /* Store device name */
        const char *name = [[g_device name] UTF8String];
        if (name) {
            strncpy(g_device_name, name, sizeof(g_device_name) - 1);
        }

        /* Load Metal library */
        id<MTLLibrary> library = load_metal_library(g_device);
        if (!library) return -1;

        /* Create compute pipeline states */
        NSError *error = nil;
        id<MTLFunction> func320 = [library newFunctionWithName:@"fermat_kernel_320"];
        id<MTLFunction> func352 = [library newFunctionWithName:@"fermat_kernel_352"];

        if (!func320 || !func352) {
            fprintf(stderr, "Metal: kernel functions not found\n");
            return -1;
        }

        g_pipeline_320 = [g_device newComputePipelineStateWithFunction:func320 error:&error];
        if (!g_pipeline_320) {
            fprintf(stderr, "Metal: pipeline 320 failed: %s\n", metal_errstr(error));
            return -1;
        }

        g_pipeline_352 = [g_device newComputePipelineStateWithFunction:func352 error:&error];
        if (!g_pipeline_352) {
            fprintf(stderr, "Metal: pipeline 352 failed: %s\n", metal_errstr(error));
            return -1;
        }

        /* Create command queue */
        g_queue = [g_device newCommandQueue];
        if (!g_queue) return -1;

        /* Get optimal thread execution width */
        g_thread_width = [g_pipeline_320 threadExecutionWidth];

        g_initialized = 1;
        return 0;
    }
}

void metal_fermat_cleanup(void) {
    if (!g_initialized) return;

    @autoreleasepool {
        g_primes_buf = nil;
        g_results_buf = nil;
        g_count_buf = nil;
        g_pipeline_320 = nil;
        g_pipeline_352 = nil;
        g_queue = nil;
        g_device = nil;
        g_initialized = 0;
        g_max_candidates = 0;
    }
}

int metal_fermat_batch(uint8_t *h_results, const uint32_t *h_primes,
                       uint32_t count, int bits) {
    if (!g_initialized) return -1;
    if (count == 0) return 0;

    @autoreleasepool {
        int limbs = (bits <= 320) ? 10 : 11;
        size_t primes_size = (size_t)count * limbs * sizeof(uint32_t);
        size_t results_size = (size_t)count * sizeof(uint8_t);

        /* Ensure buffers are large enough */
        if (ensure_buffers(count, bits) != 0) return -1;

        /* Copy input data into shared buffer (zero-copy: CPU and GPU
         * share the same physical memory on Apple Silicon) */
        memcpy([g_primes_buf contents], h_primes, primes_size);

        /* Write count into the count buffer */
        *(uint32_t *)([g_count_buf contents]) = count;

        /* Select pipeline */
        id<MTLComputePipelineState> pipeline = (bits <= 320) ? g_pipeline_320 : g_pipeline_352;

        /* Create command buffer and encoder */
        id<MTLCommandBuffer> cmdBuf = [g_queue commandBuffer];
        if (!cmdBuf) return -1;

        id<MTLComputeCommandEncoder> encoder = [cmdBuf computeCommandEncoder];
        if (!encoder) return -1;

        [encoder setComputePipelineState:pipeline];
        [encoder setBuffer:g_results_buf offset:0 atIndex:0];
        [encoder setBuffer:g_primes_buf offset:0 atIndex:1];
        [encoder setBuffer:g_count_buf offset:0 atIndex:2];

        /* Dispatch threads */
        MTLSize gridSize = MTLSizeMake(count, 1, 1);
        MTLSize threadGroupSize = MTLSizeMake(g_thread_width, 1, 1);
        [encoder dispatchThreads:gridSize threadsPerThreadgroup:threadGroupSize];
        [encoder endEncoding];

        /* Submit and wait with timeout.
         * SECURITY: waitUntilCompleted blocks indefinitely if the GPU
         * hangs. Use a semaphore with a 5-second deadline instead. */
        dispatch_semaphore_t sema = dispatch_semaphore_create(0);
        [cmdBuf addCompletedHandler:^(id<MTLCommandBuffer> _Nonnull) {
            dispatch_semaphore_signal(sema);
        }];
        [cmdBuf commit];
        long wait_result = dispatch_semaphore_wait(sema,
            dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)));
        if (wait_result != 0) {
            fprintf(stderr, "Metal: command buffer timeout (5s)\n");
            return -1;
        }

        /* Check for errors */
        if ([cmdBuf status] == MTLCommandBufferStatusError) {
            fprintf(stderr, "Metal: command buffer error: %s\n",
                    metal_errstr([cmdBuf error]));
            return -1;
        }

        /* Copy results from shared buffer back to caller */
        memcpy(h_results, [g_results_buf contents], results_size);
        return 0;
    }
}

int metal_get_device_count(void) {
    @autoreleasepool {
        NSArray<id<MTLDevice>> *devices = MTLCopyAllDevices();
        if (devices) return (int)[devices count];

        /* Fallback: check system default device */
        id<MTLDevice> dev = MTLCreateSystemDefaultDevice();
        return dev ? 1 : 0;
    }
}

const char* metal_get_device_name(int device_id) {
    static char name[256] = "Unknown";

    @autoreleasepool {
        if (g_initialized && g_device_name[0]) {
            return g_device_name;
        }

        NSArray<id<MTLDevice>> *devices = MTLCopyAllDevices();
        if (!devices || [devices count] == 0) {
            id<MTLDevice> dev = MTLCreateSystemDefaultDevice();
            if (dev) {
                strncpy(name, [[dev name] UTF8String], sizeof(name) - 1);
            }
            return name;
        }

        NSUInteger idx = (device_id >= 0 && (NSUInteger)device_id < [devices count])
                         ? (NSUInteger)device_id : 0;
        strncpy(name, [[devices[idx] name] UTF8String], sizeof(name) - 1);
        return name;
    }
}

size_t metal_get_device_memory(int device_id) {
    @autoreleasepool {
        id<MTLDevice> dev = nil;

        NSArray<id<MTLDevice>> *devices = MTLCopyAllDevices();
        if (devices && [devices count] > 0) {
            NSUInteger idx = (device_id >= 0 && (NSUInteger)device_id < [devices count])
                             ? (NSUInteger)device_id : 0;
            dev = devices[idx];
        } else {
            dev = MTLCreateSystemDefaultDevice();
        }

        if (!dev) return 0;
        return (size_t)[dev recommendedMaxWorkingSetSize];
    }
}

int metal_is_available(void) {
    @autoreleasepool {
        id<MTLDevice> dev = MTLCreateSystemDefaultDevice();
        return dev ? 1 : 0;
    }
}
